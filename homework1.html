<!DOCTYPE html>
<html>

<p> </p>
<button id="zInc">Increase Z</button>
<button id="zDec">Decrease Z</button>
<button id="rInc">Increase R</button>
<button id="rDec">Decrease R</button>

<p> </p>
<button id="thInc">Increase theta</button>
<button id="thDec">Decrease theta</button>
<button id="phiInc">Increase phi</button>
<button id="phiDec">Decrease phi</button>
<p> </p>

<script id="vertex-shader" type="x-shader/x-vertex">
#version 300 es

in vec4 aPosition;
in vec3 aNormal;
in vec2 aTexCoord;
//in  vec4 aColor;
out vec3 E;
out vec3 L;
out vec3 N;
out vec3 s_L;
//out vec4 vColor;
out vec2 vTexCoord;

uniform vec3 uTheta;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec4 uSpecularProduct;
uniform vec4 uLightPosition;
uniform float uShininess;
uniform vec4 sSpecularProduct;
uniform vec4 sLightPosition;

void main()
{
    vec3 angles = radians(uTheta);
    vec3 c = cos(angles);
    vec3 s = sin(angles);
    mat4 rx = mat4(1.0,  0.0,  0.0, 0.0,
            0.0,  c.x,  s.x, 0.0,
            0.0, -s.x,  c.x, 0.0,
            0.0,  0.0,  0.0, 1.0);

    mat4 ry = mat4(c.y, 0.0, -s.y, 0.0,
            0.0, 1.0,  0.0, 0.0,
            s.y, 0.0,  c.y, 0.0,
            0.0, 0.0,  0.0, 1.0);


    mat4 rz = mat4(c.z, s.z, 0.0, 0.0,
            -s.z,  c.z, 0.0, 0.0,
            0.0,  0.0, 1.0, 0.0,
            0.0,  0.0, 0.0, 1.0); //--Extra


    vec3 pos = (uModelViewMatrix*rz*ry*rx*aPosition).xyz;
    E = normalize(-pos);
    vec4 NN = vec4(aNormal,0);
    // Transform vertex normal into eye coordinates
    N = normalize((uModelViewMatrix*rz*ry*rx*NN).xyz);

    //Direction Light Computations
    vec3 light = (uModelViewMatrix*uLightPosition).xyz;
    //vec3 L = normalize(light - pos); //for point li
    //vec3 L;
    if(uLightPosition.w == 0.0)  L = normalize(light);
    else  L = normalize(light - pos);

/*    vec3 H = normalize(L + E);

    // Compute terms in the illumination equation
    vec4 d_ambient = uAmbientProduct;

    float Kd = max(dot(L, N), 0.0);
    vec4  d_diffuse = Kd*uDiffuseProduct;

    float Ks = pow( max(dot(N, H), 0.0), uShininess );
    vec4  d_specular = Ks*uSpecularProduct;

    if( dot(L, N) < 0.0 ) {
      d_specular = vec4(0.0, 0.0, 0.0, 1.0);
    }*/

    //Spotlight Computations
    vec3 s_light = (uModelViewMatrix*sLightPosition).xyz;
    s_L = normalize(s_light - pos);
    // if(sl_flag) {

    //     vec3 s_H = normalize(s_L + E);
        
    //     vec4 s_ambient = sAmbientProduct;
    //     float s_Kd = max(dot(s_L, N), 0.0);
    //     vec4  s_diffuse = s_Kd*sDiffuseProduct;
    //     float s_Ks = pow( max(dot(N, s_H), 0.0), uShininess );
    //     vec4  s_specular = s_Ks*sSpecularProduct;
    //     if( dot(s_L, N) < 0.0 ) {
    //       s_specular = vec4(0.0, 0.0, 0.0, 1.0);
    //     }

    vTexCoord = aTexCoord;
    gl_Position = uProjectionMatrix*uModelViewMatrix*rz*ry*rx*aPosition;
    //gl_Position.z = -gl_Position.z;
    // vColor = ambient + diffuse + specular;
    // vColor.a = 1.0;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
#version 300 es

precision mediump float;

uniform vec4 uAmbientProduct, uDiffuseProduct;
uniform vec4 sAmbientProduct, sDiffuseProduct;
uniform vec4 sLightDirection;
uniform bool sl_flag;
uniform float sCutoff;

in vec3 E;
in vec3 L;
in vec3 N;
in vec3 s_L;
//in vec4 vColor;
in vec2 vTexCoord;
out vec4 fColor;
uniform sampler2D uTextureMap;
uniform bool tx_flag;

void
main()
{   
    vec4 Ci_spot = sAmbientProduct + sDiffuseProduct;
    vec4 Cs_spot = sAmbientProduct;
    vec4 Ci_dir = uAmbientProduct + uDiffuseProduct;
    vec4 Cs_dir = uAmbientProduct;

    vec4 color = Cs_dir;
    vec4 color_spot = vec4(0.0, 0.0, 0.0, 0.0);

    if (max(dot(L, N), 0.0)>=0.5) {
        color = Ci_dir; 
    }

    if (sl_flag) {
        vec3 s_D = sLightDirection.xyz;
        float s_effect= (dot(normalize(s_D), normalize((s_L+E))));
        if (s_effect>cos(sCutoff)) {
            float att = pow( s_effect, 2.0 ); //Non-linear Attenuation
            color_spot = Cs_spot*att;
            if (max(dot(s_L, N), 0.0)>=0.5) {
                color_spot = Ci_spot*att;
            }
        }
    }
    vec4 cartoon = color + color_spot;
    cartoon.a = 1.0;
/*    fColor = Ci_dir+Cs_dir+Ci_spot+Cs_spot;
    fColor.a = 1.0;*/
    if(tx_flag) fColor = cartoon * texture(uTextureMap, vTexCoord);
    else fColor = cartoon;
}
</script>

<script type="text/javascript" src="../Common/InitShaders.js"></script>
<script type="text/javascript" src="../Common/MVnew.js"></script>
<script type="text/javascript" src="homework1.js"></script>

<body>
    <canvas id="gl-canvas" width="512" height="512">
        Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
    <img id = "texImage" src = "om.png" hidden></img>
    <br />

    <button id="xRot">Rotate X</button>
    <button id="yRot">Rotate Y</button>
    <button id="zRot">Rotate Z</button>
    <button id="tRot">Toggle Rotation</button>

    <br />
    <button id="tSpot">Toggle Spotlight</button>
    <button id="tTex">Toggle Texture</button>

</body>

</html>